# Desk - Trading Dashboard System Architecture

**Version:** 1.0
**Last Updated:** 2025-12-13
**Status:** Initial Architecture Specification

---

## Executive Summary

This document defines the complete system architecture for **Desk** - a Next.js trading dashboard for US equity quant visualization. The system is a **read-only consumer** of data from the quant pipeline (`/Volumes/Data/quant/`), providing real-time visualization of stock data, portfolio positions, and L3 trading signals.

### Key Architectural Principles

1. **Read-First Design** - Dashboard views are read-only; write operations reserved for position management
2. **Direct Database Access** - `better-sqlite3` for synchronous SQLite queries in API routes
3. **Server-Side Data Fetching** - API routes fetch data, client components render
4. **Chart-Centric UI** - TradingView for candlesticks, Recharts for analytics
5. **Type-Safe Data Layer** - Zod validation at API boundaries
6. **Performance-First** - Turbopack, lazy-loaded charts, virtualized tables
7. **Production Observability** - Pino structured logging, OpenTelemetry tracing, request correlation

---

## Table of Contents

1. [Technology Stack](#1-technology-stack)
2. [System Architecture](#2-system-architecture)
3. [4-Layer Architecture Deep Dive](#3-4-layer-architecture-deep-dive)
4. [Data Access Patterns](#4-data-access-patterns)
5. [API Design](#5-api-design)
6. [Frontend Architecture](#6-frontend-architecture)
7. [Chart Integration](#7-chart-integration)
8. [State Management](#8-state-management)
9. [Performance Strategy](#9-performance-strategy)
10. [Observability & Logging](#10-observability--logging)
11. [Testing Strategy](#11-testing-strategy)
12. [Future: Position Management](#12-future-position-management)

---

## 1. Technology Stack

### Core Dependencies

```json
{
  "dependencies": {
    "next": "^16.0.0",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "typescript": "^5.7.0",
    "better-sqlite3": "^11.0.0",
    "lightweight-charts": "^4.2.0",
    "recharts": "^2.15.0",
    "zustand": "^5.0.0",
    "zod": "^3.24.0",
    "date-fns": "^4.1.0",
    "pino": "^9.6.0",
    "uuid": "^11.0.0",
    "@radix-ui/react-*": "latest",
    "tailwind-merge": "^2.5.0",
    "class-variance-authority": "^0.7.0"
  },
  "devDependencies": {
    "pino-pretty": "^13.0.0",
    "@vercel/otel": "^1.10.0",
    "@opentelemetry/api": "^1.9.0"
  }
}
```

### Technology Decisions

| Technology | Choice | Rationale |
|------------|--------|-----------|
| **Framework** | Next.js 16 | Turbopack (5-10x faster), Cache Components, PPR |
| **React** | 19.2.3 | Activity API, useEffectEvent, security patches |
| **Database** | better-sqlite3 | Sync reads in API routes, no connection pooling needed |
| **Candlestick Charts** | TradingView Lightweight | Industry standard, performant, feature-rich |
| **Analytics Charts** | Recharts | shadcn/ui integration, composable |
| **State** | Zustand | Simple, no boilerplate, supports selectors |
| **Validation** | Zod | TypeScript-first, runtime validation at API boundaries |
| **Styling** | Tailwind CSS | Utility-first, design token integration |
| **Components** | shadcn/ui | Accessible, customizable, Radix-based |
| **Logging** | Pino | 5x faster than Winston, structured JSON, child loggers |
| **Tracing** | OpenTelemetry | Vendor-agnostic, Next.js native support |
| **NOT Using** | Prisma/Drizzle | Overkill for read-only SQLite access |
| **NOT Using** | Winston | Slower than Pino, more complex setup |
| **NOT Using** | React Query | API routes handle caching, no client-side fetching |
| **NOT Using** | tRPC | Simple REST sufficient for dashboard |

---

## 2. System Architecture

### Layer Structure

```
┌─────────────────────────────────────────────────────────────────┐
│                     Frontend (React 19.2)                        │
│  ┌──────────────────────┐  ┌────────────────────────────────┐   │
│  │  Dashboard Views     │  │  Stock Detail                  │   │
│  │  - Portfolio summary │  │  - Candlestick chart           │   │
│  │  - Watchlist         │  │  - Technical indicators        │   │
│  │  - Screener table    │  │  - L3 verdict display          │   │
│  └──────────────────────┘  └────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  API Layer (Route Handlers)                      │
│  GET /api/stocks              - Stock screener list              │
│  GET /api/stocks/[ticker]     - Stock detail + OHLCV             │
│  GET /api/portfolio           - Portfolio positions              │
│  GET /api/portfolio/summary   - Portfolio metrics                │
│  GET /api/l3/[ticker]         - L3 contract verdicts             │
│  GET /api/trading-date        - Current trading date             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Data Access Layer                             │
│  ┌────────────────┐  ┌────────────────┐  ┌──────────────────┐   │
│  │ StockQueries   │  │ PortfolioQuery │  │ L3ContractLoader │   │
│  │ - getStocks()  │  │ - getPositions │  │ - loadContract() │   │
│  │ - getDetail()  │  │ - getSummary() │  │ - parseVerdict() │   │
│  │ - getOHLCV()   │  │                │  │                  │   │
│  └────────────────┘  └────────────────┘  └──────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   External Data Sources                          │
│  ┌────────────────────────────┐  ┌───────────────────────────┐  │
│  │  SQLite Database           │  │  L3 Contract Files        │  │
│  │  /Volumes/Data/quant/      │  │  /Volumes/Data/quant/     │  │
│  │  data/stocks.db            │  │  data/contracts/{date}/   │  │
│  │  (read-only)               │  │  l3_10_{ticker}.json      │  │
│  └────────────────────────────┘  └───────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Request Flow

```
1. User navigates to /stocks/AAPL

2. Page Component (Server Component)
   ├─ Fetch stock detail from API route
   └─ Render page shell with loading states

3. API Route Handler (GET /api/stocks/AAPL)
   ├─ Get current trading date from trading_days table
   ├─ Query stock data (OHLCV + indicators + technicals)
   ├─ Load L3 contract from filesystem
   ├─ Validate response with Zod schema
   └─ Return JSON response

4. Client Components
   ├─ PriceChart receives OHLCV data
   │  └─ Initialize TradingView chart
   ├─ IndicatorPanel receives technicals
   │  └─ Render Recharts visualizations
   └─ VerdictCard receives L3 data
      └─ Display signal with confidence

5. Response renders with full interactivity
```

### Project Structure

```
desk/
├── src/
│   ├── app/                      # Next.js App Router
│   │   ├── page.tsx              # Dashboard home
│   │   ├── layout.tsx            # Root layout
│   │   ├── stocks/
│   │   │   ├── page.tsx          # Stock screener
│   │   │   └── [ticker]/
│   │   │       └── page.tsx      # Stock detail
│   │   ├── portfolio/
│   │   │   └── page.tsx          # Portfolio view
│   │   └── api/
│   │       ├── stocks/
│   │       │   ├── route.ts      # GET /api/stocks
│   │       │   └── [ticker]/
│   │       │       └── route.ts  # GET /api/stocks/[ticker]
│   │       ├── portfolio/
│   │       │   ├── route.ts      # GET /api/portfolio
│   │       │   └── summary/
│   │       │       └── route.ts  # GET /api/portfolio/summary
│   │       ├── l3/
│   │       │   └── [ticker]/
│   │       │       └── route.ts  # GET /api/l3/[ticker]
│   │       └── trading-date/
│   │           └── route.ts      # GET /api/trading-date
│   │
│   ├── components/
│   │   ├── ui/                   # shadcn/ui components
│   │   ├── charts/
│   │   │   ├── PriceChart.tsx    # TradingView candlestick
│   │   │   ├── VolumeChart.tsx   # Volume bars
│   │   │   └── IndicatorChart.tsx # Recharts analytics
│   │   ├── tables/
│   │   │   ├── StockTable.tsx    # Screener table
│   │   │   └── PositionTable.tsx # Portfolio positions
│   │   └── cards/
│   │       ├── MetricCard.tsx    # KPI display
│   │       └── VerdictCard.tsx   # L3 signal display
│   │
│   ├── lib/
│   │   ├── db.ts                 # better-sqlite3 singleton
│   │   ├── queries/
│   │   │   ├── stocks.ts         # Stock data queries
│   │   │   ├── portfolio.ts      # Portfolio queries
│   │   │   └── trading-days.ts   # Trading date queries
│   │   ├── loaders/
│   │   │   └── l3-contracts.ts   # L3 JSON file loader
│   │   ├── schemas/
│   │   │   ├── stock.ts          # Zod schemas for stocks
│   │   │   ├── portfolio.ts      # Zod schemas for portfolio
│   │   │   └── l3.ts             # Zod schemas for L3
│   │   ├── utils/
│   │   │   ├── format.ts         # Number/date formatting
│   │   │   └── colors.ts         # Semantic color helpers
│   │   └── constants.ts          # App constants
│   │
│   ├── stores/
│   │   ├── ui-store.ts           # UI state (sidebar, theme)
│   │   └── filter-store.ts       # Screener filters
│   │
│   └── types/
│       ├── stock.ts              # Stock type definitions
│       ├── portfolio.ts          # Portfolio types
│       └── l3.ts                 # L3 contract types
│
├── docs/
│   └── 0.system-architecture.md  # This document
│
├── .claude/
│   └── context/
│       └── design-principles.md  # UI guidelines
│
├── CLAUDE.md                     # Project instructions
├── HANDOVER.md                   # Implementation status
└── package.json
```

---

## 3. 4-Layer Architecture Deep Dive

### Layer 1: Presentation (React Components)

| Aspect | Details |
|--------|---------|
| **Location** | `src/components/`, `src/app/**/page.tsx` |
| **Responsibilities** | • Render UI with shadcn/ui components<br/>• Handle user interactions<br/>• Manage local UI state<br/>• Display charts with TradingView/Recharts |
| **Key Patterns** | • Server Components for data fetching<br/>• Client Components for interactivity (`'use client'`)<br/>• Composition over inheritance<br/>• Props-driven data flow |
| **Component Categories** | • `ui/` - shadcn primitives (Button, Card, Table)<br/>• `charts/` - TradingView + Recharts wrappers<br/>• `tables/` - Data tables with sorting/filtering<br/>• `cards/` - Metric and verdict displays |

---

### Layer 2: API Routes (Data Orchestration)

| Aspect | Details |
|--------|---------|
| **Location** | `src/app/api/**/route.ts` |
| **Responsibilities** | • Handle HTTP requests (GET only for dashboard)<br/>• Orchestrate data from multiple sources<br/>• Validate responses with Zod<br/>• Return JSON with proper status codes |
| **Key Patterns** | • Route Handlers (not Server Actions)<br/>• Sync database calls (better-sqlite3)<br/>• Response validation before return<br/>• Error handling with consistent format |
| **Design Rules** | • Always get trading date from `trading_days` table<br/>• Never use `MAX(date)` on data tables<br/>• Validate all responses with Zod schemas |

---

### Layer 3: Data Access (Queries & Loaders)

| Aspect | Details |
|--------|---------|
| **Location** | `src/lib/queries/`, `src/lib/loaders/` |
| **Responsibilities** | • Execute SQLite queries via better-sqlite3<br/>• Load L3 contract JSON files<br/>• Transform raw data to typed objects<br/>• Handle missing data gracefully |
| **Key Patterns** | • Pure functions (query in, typed data out)<br/>• Prepared statements for performance<br/>• Explicit JOIN patterns (no ORM magic)<br/>• Null coalescing for optional fields |
| **Database Singleton** | `src/lib/db.ts` - Single better-sqlite3 instance |

---

### Layer 4: External Data Sources

| Aspect | Details |
|--------|---------|
| **SQLite Database** | `/Volumes/Data/quant/data/stocks.db` |
| **L3 Contracts** | `/Volumes/Data/quant/data/contracts/{date}/l3_10_{ticker}.json` |
| **Access Mode** | Read-only (dashboard), Write (future position management) |
| **Key Tables** | `trading_days`, `stocks_ohlcv`, `stocks_indicators`, `stocks_technicals`, `candle_descriptors`, `l3_contracts_10`, `l3_contracts_20`, `portfolio_positions` |

---

## 4. Data Access Patterns

### Database Singleton

```typescript
// src/lib/db.ts
import Database from 'better-sqlite3';

const DB_PATH = process.env.DB_PATH || '/Volumes/Data/quant/data/stocks.db';

// Singleton instance - reused across API routes
const db = new Database(DB_PATH, { readonly: true });

// Enable WAL mode for better read performance
db.pragma('journal_mode = WAL');

export default db;
```

### Trading Date Pattern

```typescript
// src/lib/queries/trading-days.ts
import db from '../db';

export function getLatestTradingDate(): string {
  const row = db
    .prepare('SELECT date FROM trading_days WHERE day_rank = 1')
    .get() as { date: string };
  return row.date;
}

export function getTradingDateByRank(rank: number): string {
  const row = db
    .prepare('SELECT date FROM trading_days WHERE day_rank = ?')
    .get(rank) as { date: string };
  return row.date;
}
```

### Stock Query Pattern

```typescript
// src/lib/queries/stocks.ts
import db from '../db';
import { getLatestTradingDate } from './trading-days';

export function getStockDetail(ticker: string) {
  const date = getLatestTradingDate();

  const row = db.prepare(`
    SELECT
      o.ticker, o.date, o.open, o.high, o.low, o.close, o.volume,
      i.sma_20, i.sma_50, i.rsi_14, i.macd, i.macd_signal,
      t.atr_14, t.bb_upper, t.bb_lower
    FROM stocks_ohlcv o
    LEFT JOIN stocks_indicators i ON o.ticker = i.ticker AND o.date = i.date
    LEFT JOIN stocks_technicals t ON o.ticker = t.ticker AND o.date = t.date
    WHERE o.ticker = ? AND o.date = ?
  `).get(ticker, date);

  return row;
}
```

### L3 Contract Loader Pattern

```typescript
// src/lib/loaders/l3-contracts.ts
import { readFileSync, existsSync } from 'fs';
import { getLatestTradingDate } from '../queries/trading-days';

const CONTRACTS_BASE = '/Volumes/Data/quant/data/contracts';

export function loadL3Contract(ticker: string, lookback: 10 | 20 = 10) {
  const date = getLatestTradingDate();
  const path = `${CONTRACTS_BASE}/${date}/l3_${lookback}_${ticker}.json`;

  if (!existsSync(path)) {
    return null;
  }

  const raw = readFileSync(path, 'utf-8');
  return JSON.parse(raw);
}
```

---

## 5. API Design

### Endpoint Overview

| Endpoint | Method | Description | Response |
|----------|--------|-------------|----------|
| `/api/trading-date` | GET | Current trading date | `{ date: "2025-12-13" }` |
| `/api/stocks` | GET | Stock screener list | `{ stocks: [...], count: 500 }` |
| `/api/stocks/[ticker]` | GET | Stock detail + OHLCV | `{ ticker, price, change, ohlcv: [...] }` |
| `/api/portfolio` | GET | Portfolio positions | `{ positions: [...], totalValue: 125000 }` |
| `/api/portfolio/summary` | GET | Portfolio metrics | `{ totalValue, dayChange, totalPnL }` |
| `/api/l3/[ticker]` | GET | L3 contract verdict | `{ verdict, confidence, signals: [...] }` |

### Response Schema Pattern

```typescript
// src/lib/schemas/stock.ts
import { z } from 'zod';

export const StockDetailSchema = z.object({
  ticker: z.string(),
  date: z.string(),
  open: z.number(),
  high: z.number(),
  low: z.number(),
  close: z.number(),
  volume: z.number(),
  change: z.number(),
  changePercent: z.number(),
  indicators: z.object({
    sma20: z.number().nullable(),
    sma50: z.number().nullable(),
    rsi14: z.number().nullable(),
  }),
});

export type StockDetail = z.infer<typeof StockDetailSchema>;
```

### Route Handler Pattern

```typescript
// src/app/api/stocks/[ticker]/route.ts
import { NextResponse } from 'next/server';
import { getStockDetail, getStockOHLCV } from '@/lib/queries/stocks';
import { loadL3Contract } from '@/lib/loaders/l3-contracts';
import { StockDetailSchema } from '@/lib/schemas/stock';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ ticker: string }> }
) {
  const { ticker } = await params;

  try {
    const detail = getStockDetail(ticker.toUpperCase());

    if (!detail) {
      return NextResponse.json(
        { error: 'Stock not found' },
        { status: 404 }
      );
    }

    const ohlcv = getStockOHLCV(ticker.toUpperCase(), 252); // 1 year
    const l3 = loadL3Contract(ticker.toUpperCase());

    const response = {
      ...detail,
      ohlcv,
      l3,
    };

    // Validate before returning
    const validated = StockDetailSchema.parse(response);

    return NextResponse.json(validated);
  } catch (error) {
    console.error('Stock detail error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

---

## 6. Frontend Architecture

### Component Hierarchy

```
app/
├── layout.tsx (Server)
│   └── Sidebar + main content area
│
├── page.tsx (Server) - Dashboard
│   ├── MetricCard (Server) - Portfolio value
│   ├── MetricCard (Server) - Day change
│   ├── PositionTable (Client) - Top positions
│   └── WatchlistTable (Client) - Watchlist
│
├── stocks/page.tsx (Server) - Screener
│   ├── FilterBar (Client) - Filters state
│   └── StockTable (Client) - Sortable, virtualized
│
└── stocks/[ticker]/page.tsx (Server) - Detail
    ├── PriceChart (Client) - TradingView
    ├── VolumeChart (Client) - TradingView
    ├── IndicatorPanel (Client) - Recharts
    └── VerdictCard (Server) - L3 signal
```

### Server vs Client Component Rules

| Use Server Component | Use Client Component |
|---------------------|---------------------|
| Data fetching | TradingView charts |
| Static content | Interactive tables |
| Metadata/SEO | Form inputs |
| Layout structure | State-dependent UI |
| Initial render | Event handlers |

### Client Component Pattern

```typescript
// src/components/charts/PriceChart.tsx
'use client';

import { createChart, IChartApi } from 'lightweight-charts';
import { useEffect, useRef } from 'react';

interface OHLCV {
  time: string;
  open: number;
  high: number;
  low: number;
  close: number;
}

interface PriceChartProps {
  data: OHLCV[];
  height?: number;
}

export function PriceChart({ data, height = 400 }: PriceChartProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const chart = createChart(containerRef.current, {
      height,
      layout: {
        background: { type: 'solid', color: 'transparent' },
        textColor: 'hsl(var(--muted-foreground))',
      },
      grid: {
        vertLines: { color: 'hsl(var(--border))' },
        horzLines: { color: 'hsl(var(--border))' },
      },
      crosshair: { mode: 1 },
      timeScale: { borderColor: 'hsl(var(--border))' },
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: 'hsl(var(--positive))',
      downColor: 'hsl(var(--negative))',
      borderUpColor: 'hsl(var(--positive))',
      borderDownColor: 'hsl(var(--negative))',
      wickUpColor: 'hsl(var(--positive))',
      wickDownColor: 'hsl(var(--negative))',
    });

    candleSeries.setData(data);
    chart.timeScale().fitContent();
    chartRef.current = chart;

    return () => {
      chart.remove();
      chartRef.current = null;
    };
  }, [data, height]);

  return <div ref={containerRef} className="w-full" />;
}
```

---

## 7. Chart Integration

### TradingView Lightweight Charts

**Use for:** Candlestick charts, volume bars, price lines

```typescript
// Chart configuration following design principles
const chartConfig = {
  layout: {
    background: { type: 'solid', color: 'transparent' },
    textColor: 'hsl(var(--muted-foreground))',
  },
  grid: {
    vertLines: { color: 'hsl(var(--border))' },
    horzLines: { color: 'hsl(var(--border))' },
  },
  crosshair: { mode: CrosshairMode.Normal },
  timeScale: {
    borderColor: 'hsl(var(--border))',
    timeVisible: true,
  },
  rightPriceScale: {
    borderColor: 'hsl(var(--border))',
  },
};

const candlestickConfig = {
  upColor: 'hsl(var(--positive))',      // emerald-500
  downColor: 'hsl(var(--negative))',    // red-500
  borderUpColor: 'hsl(var(--positive))',
  borderDownColor: 'hsl(var(--negative))',
  wickUpColor: 'hsl(var(--positive))',
  wickDownColor: 'hsl(var(--negative))',
};
```

### Recharts

**Use for:** Indicator charts, portfolio analytics, distributions

```typescript
// Recharts with shadcn integration
import { Area, AreaChart, XAxis, YAxis, Tooltip } from 'recharts';
import { ChartContainer, ChartTooltip } from '@/components/ui/chart';

export function RSIChart({ data }: { data: { date: string; rsi: number }[] }) {
  return (
    <ChartContainer config={{ rsi: { color: 'hsl(var(--info))' } }}>
      <AreaChart data={data}>
        <XAxis dataKey="date" />
        <YAxis domain={[0, 100]} />
        <Area
          type="monotone"
          dataKey="rsi"
          stroke="hsl(var(--info))"
          fill="hsl(var(--info) / 0.2)"
        />
        <ChartTooltip />
      </AreaChart>
    </ChartContainer>
  );
}
```

---

## 8. State Management

### Zustand Store Pattern

```typescript
// src/stores/ui-store.ts
import { create } from 'zustand';

interface UIState {
  sidebarCollapsed: boolean;
  theme: 'light' | 'dark' | 'system';
  toggleSidebar: () => void;
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
}

export const useUIStore = create<UIState>((set) => ({
  sidebarCollapsed: false,
  theme: 'dark',
  toggleSidebar: () => set((state) => ({
    sidebarCollapsed: !state.sidebarCollapsed
  })),
  setTheme: (theme) => set({ theme }),
}));
```

### Filter Store Pattern

```typescript
// src/stores/filter-store.ts
import { create } from 'zustand';

interface FilterState {
  sector: string | null;
  minPrice: number | null;
  maxPrice: number | null;
  signal: 'bullish' | 'bearish' | 'neutral' | null;
  setFilter: <K extends keyof FilterState>(key: K, value: FilterState[K]) => void;
  resetFilters: () => void;
}

const initialFilters = {
  sector: null,
  minPrice: null,
  maxPrice: null,
  signal: null,
};

export const useFilterStore = create<FilterState>((set) => ({
  ...initialFilters,
  setFilter: (key, value) => set({ [key]: value }),
  resetFilters: () => set(initialFilters),
}));
```

### When to Use Zustand vs Local State

| Use Zustand | Use useState |
|-------------|--------------|
| Shared across components | Single component |
| Persisted UI preferences | Ephemeral UI state |
| Filter/sort state | Form input values |
| Sidebar/modal state | Hover/focus states |

---

## 9. Performance Strategy

### Data Loading

| Strategy | Implementation |
|----------|----------------|
| **Server Components** | Fetch data in RSC, no client waterfalls |
| **Streaming** | Use Suspense boundaries for progressive loading |
| **Caching** | Next.js 16 Cache Components + `use cache` |
| **Revalidation** | Time-based for market data (1 min during trading hours) |

### Rendering

| Strategy | Implementation |
|----------|----------------|
| **Lazy Loading** | Dynamic import for charts below fold |
| **Virtualization** | Use `@tanstack/react-virtual` for 500+ row tables |
| **Skeleton Loading** | Show layout structure while data loads |
| **Turbopack** | Default bundler for 5-10x faster refresh |

### Charts

| Strategy | Implementation |
|----------|----------------|
| **Canvas Rendering** | TradingView uses canvas (not SVG) |
| **Data Windowing** | Only render visible candles |
| **Debounced Resize** | Throttle chart resize handlers |

### Bundle Size

| Strategy | Implementation |
|----------|----------------|
| **Tree Shaking** | Import only needed Recharts components |
| **Code Splitting** | Per-route chunks via App Router |
| **Dynamic Imports** | `dynamic(() => import('./PriceChart'), { ssr: false })` |

---

## 10. Observability & Logging

### Overview

Production-grade observability using industry best practices:

| Component | Technology | Purpose |
|-----------|------------|---------|
| **Logging** | Pino | Structured JSON logs, 5x faster than Winston |
| **Tracing** | OpenTelemetry | Distributed tracing, Next.js native support |
| **Metrics** | Structured Logs | Log-based metrics (no separate collector) |
| **Error Tracking** | Pino + JSONL | Failed request tracking for post-mortem |

### Dependencies

```json
{
  "dependencies": {
    "pino": "^9.6.0",
    "pino-pretty": "^13.0.0"
  },
  "devDependencies": {
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/sdk-node": "^0.57.0",
    "@opentelemetry/auto-instrumentations-node": "^0.55.0",
    "@opentelemetry/instrumentation-pino": "^0.46.0",
    "@vercel/otel": "^1.10.0"
  }
}
```

### The 2-Logger Pattern

Following production best practices, we use two distinct logger types:

```typescript
// src/lib/logger.ts
import pino from 'pino';
import { AsyncLocalStorage } from 'async_hooks';

// Request context storage
export const requestContext = new AsyncLocalStorage<{
  requestId: string;
  startTime: number;
}>();

// Base logger - for service lifecycle events (no request context)
export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV === 'development'
    ? { target: 'pino-pretty', options: { colorize: true } }
    : undefined,
  formatters: {
    level: (label) => ({ level: label }),
  },
  base: {
    service: 'desk',
    env: process.env.NODE_ENV,
  },
});

// Request logger - automatically includes requestId from AsyncLocalStorage
export function getLogger() {
  const context = requestContext.getStore();
  if (!context) {
    return logger; // Fallback to base logger
  }
  return logger.child({
    requestId: context.requestId,
  });
}
```

### Request Correlation Pattern

Every API request gets a unique ID that propagates through all logs:

```typescript
// src/lib/middleware/request-context.ts
import { v4 as uuidv4 } from 'uuid';
import { requestContext, getLogger } from '@/lib/logger';

export function withRequestContext<T>(
  handler: () => Promise<T>
): Promise<T> {
  const requestId = uuidv4();
  const startTime = Date.now();

  return requestContext.run({ requestId, startTime }, async () => {
    const log = getLogger();
    log.info('Request started');

    try {
      const result = await handler();
      log.info({ latencyMs: Date.now() - startTime }, 'Request completed');
      return result;
    } catch (error) {
      log.error({ error, latencyMs: Date.now() - startTime }, 'Request failed');
      throw error;
    }
  });
}
```

### Route Handler with Observability

```typescript
// src/app/api/stocks/[ticker]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withRequestContext, getLogger } from '@/lib/logger';
import { getStockDetail } from '@/lib/queries/stocks';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ ticker: string }> }
) {
  return withRequestContext(async () => {
    const { ticker } = await params;
    const log = getLogger();
    const startTime = Date.now();

    log.info({ ticker }, 'Fetching stock detail');

    try {
      const detail = getStockDetail(ticker.toUpperCase());

      if (!detail) {
        log.warn({ ticker }, 'Stock not found');
        return NextResponse.json(
          { error: 'Stock not found' },
          {
            status: 404,
            headers: { 'X-Request-ID': log.bindings().requestId }
          }
        );
      }

      log.info(
        { ticker, latencyMs: Date.now() - startTime },
        'Stock detail fetched'
      );

      return NextResponse.json(detail, {
        headers: {
          'X-Request-ID': log.bindings().requestId,
          'X-Response-Time': `${Date.now() - startTime}ms`,
        },
      });
    } catch (error) {
      log.error({ error, ticker }, 'Failed to fetch stock detail');
      return NextResponse.json(
        { error: 'Internal server error' },
        { status: 500 }
      );
    }
  });
}
```

### Structured Log Output

All logs are JSON-formatted for machine processing:

```json
{"level":"info","time":1702483200000,"service":"desk","env":"production","requestId":"550e8400-e29b-41d4-a716-446655440000","ticker":"AAPL","msg":"Fetching stock detail"}
{"level":"info","time":1702483200045,"service":"desk","env":"production","requestId":"550e8400-e29b-41d4-a716-446655440000","ticker":"AAPL","latencyMs":45,"msg":"Stock detail fetched"}
```

### OpenTelemetry Integration

Next.js 16 has built-in OpenTelemetry support:

```typescript
// instrumentation.ts (project root)
import { registerOTel } from '@vercel/otel';

export function register() {
  registerOTel({
    serviceName: 'desk-trading-dashboard',
    // Traces automatically collected for:
    // - API route handlers
    // - Server component rendering
    // - Fetch requests
  });
}
```

For self-hosted deployments with manual SDK:

```typescript
// instrumentation.node.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { PinoInstrumentation } from '@opentelemetry/instrumentation-pino';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';

const sdk = new NodeSDK({
  serviceName: 'desk-trading-dashboard',
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT,
  }),
  instrumentations: [
    getNodeAutoInstrumentations(),
    new PinoInstrumentation(),
  ],
});

sdk.start();
```

### Database Query Logging

Log all database queries with timing:

```typescript
// src/lib/db.ts
import Database from 'better-sqlite3';
import { getLogger } from './logger';

const DB_PATH = process.env.DB_PATH || '/Volumes/Data/quant/data/stocks.db';
const db = new Database(DB_PATH, { readonly: true });

db.pragma('journal_mode = WAL');

// Wrap queries with logging
export function query<T>(
  sql: string,
  params: unknown[] = [],
  operation: string
): T {
  const log = getLogger();
  const startTime = Date.now();

  try {
    const stmt = db.prepare(sql);
    const result = (params.length ? stmt.all(...params) : stmt.all()) as T;

    log.debug(
      { operation, latencyMs: Date.now() - startTime, rowCount: Array.isArray(result) ? result.length : 1 },
      'Database query executed'
    );

    return result;
  } catch (error) {
    log.error(
      { operation, error, latencyMs: Date.now() - startTime },
      'Database query failed'
    );
    throw error;
  }
}

export default db;
```

### Metrics via Structured Logging

Instead of a separate metrics collector, emit structured logs for aggregation:

```typescript
// src/lib/metrics.ts
import { getLogger } from './logger';

export function recordMetric(
  name: string,
  value: number,
  tags: Record<string, string> = {}
) {
  const log = getLogger();
  log.info(
    { metric: name, value, ...tags },
    `metric:${name}`
  );
}

// Usage in route handlers
recordMetric('api.latency', 45, { endpoint: '/api/stocks', method: 'GET' });
recordMetric('db.query.count', 1, { table: 'stocks_ohlcv' });
recordMetric('cache.hit', 1, { key: 'stock:AAPL' });
```

### Error Tracking

Track failed requests for post-mortem analysis:

```typescript
// src/lib/error-tracker.ts
import { appendFileSync } from 'fs';
import { getLogger } from './logger';

const ERROR_LOG_PATH = process.env.ERROR_LOG_PATH || 'logs/errors.jsonl';

interface ErrorRecord {
  timestamp: string;
  requestId: string;
  endpoint: string;
  error: string;
  stack?: string;
  context?: Record<string, unknown>;
}

export function trackError(
  endpoint: string,
  error: Error,
  context?: Record<string, unknown>
) {
  const log = getLogger();
  const requestId = log.bindings().requestId || 'unknown';

  const record: ErrorRecord = {
    timestamp: new Date().toISOString(),
    requestId,
    endpoint,
    error: error.message,
    stack: error.stack,
    context,
  };

  // Log to Pino
  log.error({ ...record }, 'Error tracked');

  // Append to JSONL file for analysis
  if (process.env.NODE_ENV === 'production') {
    appendFileSync(ERROR_LOG_PATH, JSON.stringify(record) + '\n');
  }
}
```

### Next.js Error Handling Hook

Capture unhandled errors in production:

```typescript
// instrumentation.ts
export function onRequestError(
  error: Error,
  request: Request,
  context: { routerKind: string; routePath: string }
) {
  // Send to error tracking service
  trackError(context.routePath, error, {
    routerKind: context.routerKind,
    url: request.url,
    method: request.method,
  });
}
```

### Log Levels by Environment

| Environment | Default Level | pino-pretty |
|-------------|---------------|-------------|
| Development | `debug` | Yes (colorized) |
| Staging | `info` | No (JSON) |
| Production | `info` | No (JSON) |

```typescript
// Environment-based configuration
const logLevel = {
  development: 'debug',
  staging: 'info',
  production: 'info',
}[process.env.NODE_ENV || 'development'];
```

### Sampling Strategy (Production)

For high-traffic scenarios:

```typescript
// src/lib/logger.ts
const SAMPLE_RATE = process.env.NODE_ENV === 'production' ? 0.1 : 1.0;

export function shouldSample(): boolean {
  return Math.random() < SAMPLE_RATE;
}

// In route handlers - sample verbose logs
if (shouldSample()) {
  log.debug({ fullPayload: data }, 'Detailed response');
}
```

### Observability Checklist

- [ ] **Request ID** - Every request has a UUID propagated through all logs
- [ ] **Structured Logging** - JSON format for machine processing
- [ ] **Log Levels** - Appropriate levels (debug/info/warn/error)
- [ ] **Latency Tracking** - All operations timed and logged
- [ ] **Error Context** - Errors include request context and stack traces
- [ ] **Database Logging** - Query timing and row counts
- [ ] **Response Headers** - X-Request-ID and X-Response-Time returned
- [ ] **OpenTelemetry** - Traces for distributed debugging
- [ ] **Production Sampling** - Reduce log volume in high-traffic scenarios
- [ ] **Error Persistence** - Failed requests saved to JSONL for analysis

### Project Structure Update

```
src/lib/
├── logger.ts              # Pino setup + 2-logger pattern
├── error-tracker.ts       # Error persistence
├── metrics.ts             # Structured metrics
└── middleware/
    └── request-context.ts # AsyncLocalStorage wrapper

logs/                      # Runtime logs (gitignored)
├── errors.jsonl           # Failed request log
└── app.log                # Application log (optional file transport)

instrumentation.ts         # OpenTelemetry setup
instrumentation.node.ts    # Node-specific OTel (self-hosted)
```

---

## 11. Testing Strategy

### Test Pyramid

```
                    ┌─────────────┐
                    │   E2E (5%)  │  Playwright
                    ├─────────────┤
                    │ Integration │  API routes + DB
                    │    (15%)    │
                    ├─────────────┤
                    │    Unit     │  Queries, utils,
                    │    (80%)    │  components
                    └─────────────┘
```

### Test Categories

| Category | Location | Tools | Focus |
|----------|----------|-------|-------|
| **Unit** | `src/**/*.test.ts` | Vitest | Queries, formatters, utils |
| **Component** | `src/components/**/*.test.tsx` | Vitest + Testing Library | Component rendering |
| **Integration** | `tests/integration/` | Vitest | API routes + database |
| **E2E** | `tests/e2e/` | Playwright | Critical user flows |

### Query Testing Pattern

```typescript
// src/lib/queries/stocks.test.ts
import { describe, it, expect } from 'vitest';
import { getStockDetail, getStockOHLCV } from './stocks';

describe('Stock Queries', () => {
  it('returns stock detail for valid ticker', () => {
    const detail = getStockDetail('AAPL');
    expect(detail).toBeDefined();
    expect(detail.ticker).toBe('AAPL');
    expect(detail.close).toBeGreaterThan(0);
  });

  it('returns null for invalid ticker', () => {
    const detail = getStockDetail('INVALID123');
    expect(detail).toBeNull();
  });

  it('returns OHLCV data for specified days', () => {
    const ohlcv = getStockOHLCV('AAPL', 20);
    expect(ohlcv).toHaveLength(20);
    expect(ohlcv[0]).toHaveProperty('open');
    expect(ohlcv[0]).toHaveProperty('high');
    expect(ohlcv[0]).toHaveProperty('low');
    expect(ohlcv[0]).toHaveProperty('close');
  });
});
```

---

## 12. Future: Position Management

### Write Operations (Planned)

When position management is implemented, the following patterns will be added:

```typescript
// Future: src/lib/mutations/positions.ts
import db from '../db';

export function updatePosition(
  ticker: string,
  quantity: number,
  avgCost: number
) {
  const stmt = db.prepare(`
    INSERT INTO portfolio_positions (acc_id, ticker, quantity, avg_cost, updated_at)
    VALUES (?, ?, ?, ?, datetime('now'))
    ON CONFLICT(acc_id, ticker) DO UPDATE SET
      quantity = excluded.quantity,
      avg_cost = excluded.avg_cost,
      updated_at = excluded.updated_at
  `);

  return stmt.run(PORTFOLIO_ACCOUNT_ID, ticker, quantity, avgCost);
}
```

### API Endpoints (Planned)

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/positions` | POST | Create/update position |
| `/api/positions/[ticker]` | DELETE | Close position |
| `/api/orders` | POST | Place order |
| `/api/orders/[id]` | PATCH | Modify order |

---

## Conclusion

This architecture specification defines a **read-optimized trading dashboard** that:

1. **Leverages Next.js 16** - Turbopack, Cache Components, React 19.2.3
2. **Direct Database Access** - better-sqlite3 for sync reads in API routes
3. **Chart-Centric Design** - TradingView for prices, Recharts for analytics
4. **Type-Safe Boundaries** - Zod validation at API responses
5. **Performance-First** - Lazy loading, virtualization, canvas rendering

### Related Documentation

| Document | Purpose |
|----------|---------|
| `CLAUDE.md` | Project instructions and critical rules |
| `HANDOVER.md` | Implementation status and phase checklist |
| `.claude/context/design-principles.md` | UI guidelines and patterns |
| `/Volumes/Data/quant/docs/frontend/FRONTEND_PLAN.md` | Full feature specification |
| `/Volumes/Data/quant/docs/intel/03_l3_stock.md` | L3 contract schema |

### Key Architectural Decisions

| Decision | Rationale |
|----------|-----------|
| better-sqlite3 over Prisma | Sync reads, no ORM overhead, direct SQL control |
| Route Handlers over Server Actions | Easier to cache, clearer data flow |
| Zustand over Context | Simpler API, better performance, no provider nesting |
| TradingView over D3 | Industry standard, better performance, built-in features |
| Zod at API boundary | Runtime validation, TypeScript inference, clear errors |
| Pino over Winston | 5x faster, structured JSON, child loggers, AsyncLocalStorage |
| OpenTelemetry over vendor SDK | Platform-agnostic, Next.js native, future-proof |

**Implementation Status:** See `HANDOVER.md` for current phase
